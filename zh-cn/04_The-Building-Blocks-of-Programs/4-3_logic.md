

逻辑

## 逻辑

**逻辑**或者更具体地说是**条件逻辑**，允许我们基于测试指定一个操作或操作集。在评估测试后，我们将得到一个布尔值，该值表示 ```True``` 或 ```False```，我们可以使用它来控制程序流。

### 布尔

数字变量可以存储整个范围的不同数字。布尔变量只能存储两个名为“True”或“False”、“Yes”或“No”、“1”或“0”的值。由于布尔范围有限，我们很少使用布尔来执行计算。

### 条件语句

“If”语句是编程中的关键概念：如果 *this* 为 True，则 *that* 发生，否则 *something else* 发生。语句的结果操作由布尔值驱动。在 Dynamo 中，有多种方法可定义“If”语句：

|图标|名称|语法|输入|输出|
| -- | -- | -- | -- | -- |
|![](../images/icons/DSCoreNodesUI-Logic-If-Large.jpg)|如果|如果|test, true, false|结果|
|![](../images/icons/DSCoreNodesUI-Formula-Large.jpg)|公式|IF(x,y,z)|x, y, z|结果|
|![](../images/icons/Dynamo-Nodes-CodeBlockNodeModel-Large.jpg)|代码块|(x?y:z)|x, y, z|结果|

接下来，我们来看一个简短示例，分别介绍这三个节点在使用“If”条件语句时的行为：

![](images/4-3/IFs.jpg)

> 在此图中，*boolean* 设置为 *true*，这意味着结果是字符串读取：*“如果为 true，这是结果”。*在此处，创建 *If* 语句的三个节点的工作方式相同。

![](images/4-3/IFs2.jpg)

> 同样，该节点的工作方式也相同。如果 *boolean* 更改为 *false*，则结果是 *Pi* 数字，如原始 *If* 语句中所定义。

### 过滤列表

> 下载本练习随附的示例文件（单击鼠标右键，然后单击“将链接另存为...”）：[构建程序块 - Logic.dyn](datasets/4-3/Building Blocks of Programs - Logic.dyn)。可以在附录中找到示例文件的完整列表。

我们使用逻辑将一列数字分隔为一列偶数和一列奇数。

![](images/4-3/01.jpg)

> 1. **Number Range** - 向画布添加一个数字范围。
2. **Numbers** - 向画布添加三个数字节点。每个数字节点的值应为：*start* 为 *0.0*、*end* 为 *10.0* 以及 *step* 为 *1.0*。
3. **Output** - 输出是一列 11 个数字（范围从 0 到 10）。
4. **求模 (%)** - *Number Range* 到 *x*，*2.0* 到 *y*。这将计算列表中每个数字除以 2 的余数。此列表的输出将给出一列介于 0 和 1 之间的交替值。
5. **相等测试 (==)** - 向画布添加相等测试。将 *modulo* 输出连接到 *x* 输入，将 *0.0* 输入连接到 *y* 输入。
6. **Watch** - 相等测试的输出是一列介于 true 和 false 之间的交替值。这些值用于分隔列表中的项目。*0*（或 *true*）表示偶数，*1*（或 *false*）表示奇数。
7. **List.FilterByBoolMask** - 此节点会根据输入布尔值将值过滤为两个不同的列表。将原始 *number range* 连接到 *list* 输入，将 *equality test* 输出连接到 *mask* 输入。*in* 输出表示 true 值，而 *out* 输出表示 false 值。
8. **Watch** - 结果，我们现在得到了一列偶数和一列奇数。我们已使用逻辑运算符将列表分成各图案！

### 从逻辑到几何图形

在第一个练习中建立的逻辑基础上，我们将此设置应用于建模操作。

![](images/4-3/02.png) 我们将从上一个具有相同节点的练习跳转。唯一的例外（除了更改格式外）:

> 1. 输入值已更改。
2. 我们已取消将列表输入连接到 *List.FilterByBoolMask*。现在，我们将这些节点放在旁边，但稍后在练习中，它们会派上用场。

![](images/4-3/03.png)

> 我们先将节点连接在一起，如上图中所示。该组节点表示参数方程，用于定义曲线。几点注意事项：

> 1. **第一个滑块**应具有最小值 1、最大值 4 和步长 0.01。
2. **第二个滑块**应具有最小值 0、最大值 1 和步长 0.01。
3. **PolyCurve.ByPoints** - 如果复制上述节点图表，则在 Dynamo 预览视口中结果为正弦曲线。

此处的输入方法：使用数字节点可获得更多静态特性，使用数字滑块可获得更多灵活特性。我们希望保留在此步骤开头定义的原始数字范围。但是，我们在此处创建的正弦曲线应该具有一定的灵活性。我们可以移动这些滑块，来观察曲线更新的频率和振幅。

![](images/4-3/04.png)

> 我们在定义中跳过一点，从而看一下最终结果，以便我们可以参照所得到的内容。前两个步骤是分别进行的，我们现在要将这两个步骤连接起来。我们将使用基础正弦曲线来驱动拉链组件的位置，我们将使用 true/false 逻辑以在小框和大框之间交替。

![](images/4-3/05.png)

> 1. **Math.RemapRange** - 使用在步骤 01 中创建的数字序列，我们通过重新映射范围来创建一系列新数字。原始数字来自步骤 01，范围为 0-100。这些数字介于 0 到 1，分别通过 *newMin* 和 *newMax* 输入。

![](images/4-3/06.png)

> 1. **Curve.PointAtParameter** - 将 *Polycurve.ByPoints*（步骤 2）连接到 *curve*，将 *Math.RemapRange* 连接到 *param*。此步骤将沿曲线创建点。我们将数字重新映射为 0 到 1，因为 *param* 的输入将查找此范围中的值。值 *0* 表示开始点，值 *1* 表示结束点。介于两者之间的所有数字均在 *[0,1]* 范围内求值。

![](images/4-3/07.png)

> 1. **List.FilterByBoolMask** - 将上一步的 *Curve.PointAtParameter* 连接到 *list* 输入。
2. **Watch** - *in* 的观察节点和 *out* 的观察节点表明，我们有表示偶数索引和奇数索引的两个列表。这些点在曲线上的排序方式相同，我们将在下一步中进行演示。

![](images/4-3/08.png)

> 1. **Cuboid.ByLengths** - 重新创建在上图中所见到的连接，以沿正弦曲线获得拉链。立方体在此处就是一个框，我们将基于框中心的曲线点定义其大小。现在，偶数/奇数分割的逻辑在模型中应该一清二楚。

![](images/4-3/matrix.png)

> 1. **Number Slider** - 后退到定义的开头，我们可以调整数字滑块并观察拉链更新。图像的顶部行表示顶部数字滑块的范围值。这是波的频率。
2. **Number Slider** - 图像的底部行表示底部滑块的值范围。这是波的振幅。

