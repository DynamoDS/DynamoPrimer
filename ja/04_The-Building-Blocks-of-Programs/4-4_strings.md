

## 文字列

**文字列**とは、正確には、リテラル定数や何らかのタイプの変数を表す一連の文字の集合のことです。広い意味では、文字列とは、テキストを意味するプログラミング用語です。ここまでの手順では、整数と小数の両方を使用してパラメータをコントロールしてきましたが、テキストについても同じ処理を行うことができます。

### 文字列を作成する

文字列は、カスタム パラメータの定義、ドキュメント セットの注釈付け、テキストベースのデータ セットの解析など、さまざまな目的で使用することができます。String ノードは、[Core] > [Input]カテゴリで使用することができます。

![String ノードの例](images/4-4/4-4-1-005.jpg)

> 上記のサンプル ノードは、すべて文字列用のノードです。数値は文字と同様に、文字列として表すことも、テキスト配列全体として表すこともできます。

### 文字列のクエリーを実行する

> この演習に付属しているサンプル ファイルをダウンロードしてください(右クリックして[名前を付けてリンク先を保存...]を選択): [Building Blocks of Programs - Strings.dyn](datasets/4-5/Building Blocks of Programs - Strings.dyn)。 すべてのサンプルファイルの一覧については、付録を参照してください。

文字列のクエリーを実行することにより、大量のデータをすばやく解析することができます。ここでは、ワークフローを促進してソフトウェアの相互運用性を向上させるための基本的な操作について説明します。

次の図は、外部のスプレッドシートから取得したデータの文字列を示しています。この文字列は、XY 面上の長方形の頂点を表しています。簡単な演習として、文字列の分割操作を確認してみましょう。

![StringSplit](images/4-4/4-4-1-001.jpg)

> 1. 「;」セパレータは、長方形の各頂点を分割します。これにより、各頂点の 4 つの項目が含まれているリストが作成されます。

![StringSplit](images/4-4/4-4-1-003.jpg)

> 1. String.Split ノードの中央にある[*+*]をクリックして、新しいセパレータを作成します。
2. 「*,*」という文字をキャンバスに追加し、separator1 入力に接続します。
3. リストの項目が 10 個になります。String.Split ノードは、*separator0* に基づいて分割を行ってから、*separator1* に基づいて分割を行います。

上記のリストの項目は数値に見えますが、Dynamo 内では個別の文字列として認識されます。点群を作成するには、データ タイプを文字列から数値に変換する必要があります。これを行うには String.ToNumber ノードを使用します。

![StringSplit](images/4-4/4-4-1-002.jpg)

> 1. String.ToNumber ノードは、単純なノードです。String.Split ノードの出力を String.ToNumber ノードの入力に接続します。出力の表示は変わりませんが、データ タイプは*文字列*から*数値*に変換されています。

![StringToNumber](images/4-4/4-4-1-004.jpg)

> 1. いくつかの基本的な操作を実行すると、元の文字列の入力に基づいて基準点に長方形が描画されます。

### 文字列を操作する

文字列は一般的なテキスト オブジェクトであるため、さまざまな目的で使用することができます。ここでは、[Core] > [String]カテゴリの主要なアクションをいくつか見てみましょう。

このカテゴリには、複数の文字列を順に結合する方法が用意されています。リストから各リテラル文字列を取得して、1 つの文字列に結合します。

![連結](images/4-4/4-4-1-007.jpg)

> 上の図は、3 つの文字列を連結する方法を示しています。

> 1. String.Concat ノード中央の[+]/[-]ボタンをクリックして、連結する文字列の追加と除外を行います。
2. 出力として、スペースと句読点を含む 1 つの連結された文字列が生成されます。

結合操作は連結操作に非常によく似ていますが、句読点のレイヤーが追加される点が異なります。

Excel を使用したことがあれば、CSV ファイルについても知っているでしょう。CSV とは、カンマ区切り値という意味です。セパレータとしてカンマ(この場合は 2 つのダッシュ)を String.Join ノードで使用すると、CSV に似たデータ構造を作成することができます。![連結](images/4-4/4-4-1-006.jpg)

> 上の図は、2 つの文字列を結合する方法を示しています。

> 1. separator 入力を使用して、結合された文字列の区切り文字を指定することができます。

### 文字列を操作する

この演習では、文字列のクエリーと文字列の操作を実行して、Robert Frost の「[Stopping By Woods on a Snowy Evening](http://www.poetryfoundation.org/poem/171621)」という詩の最後の節を分解してみましょう。 実際の開発作業で詩の文字列を操作することはありませんが、文字列に対する操作を理解するのに役立ちます。

![文字列の分割](images/4-4/4-4-4/00.jpg)

> 最初に、節の文字列を分解する基本的な操作を実行します。文字はカンマに基づいて書式設定されていることがわかります。この書式を使用して、各行を個々の項目に分割します。

> 1. ベースとなる文字列を String ノードに貼り付けます。
2. 別の String ノードを使用して、セパレータを指定します。ここでは、カンマをセパレータとして使用します。
3. String.Split ノードをキャンバスに追加し、2 つの String ノードに接続します。
4. 出力として、各行が個別の要素に分割されます。

![文字列の分割](images/4-4/4-4-4/01.jpg)

> 次に、詩のサビとなる最後の 2 行を処理しましょう。元の節は 1 つのデータ項目でした。最初の手順で、このデータを個別の項目に分割しました。そのため、必要な文字列を検索する必要があります。この例では、リストの最後にある 2 つの項目を選択することは難しくありませんが**、書籍全体が処理対象になるような場合、内容をすべて読んでから各要素を手作業で区別するのは大変な作業になります。

> 1. String.Contains ノードを使用して文字セットを検索すれば、こうした手作業を行う必要はありません。これは、文書ファイルで「検索」コマンドを実行するのと似ています。この場合、対象のサブストリングが項目内で見つかったかどうかに応じて、「true」または「false」が返されます。
2. String.Contains ノードの searchFor 入力で、節内で検索するサブストリングを定義します。ここでは、String ノードで「And miles」と指定します。
3. 出力として、false と true のリストが表示されます。次の手順では、このブール値ロジックを使用して各要素をフィルタします。

![文字列の分割](images/4-4/4-4-4/02.jpg)

> 1. List.FilterByBoolMask ノードを使用して false と true を抽出します。in 出力は、mask 入力が true になっているステートメントを返し、out 出力は、mask 入力が false になっているステートメントを返します。
2. in 出力により、節の最後の 2 行が返されます。この 2 行には、「And miles」という文字列が含まれています。

![文字列の分割](images/4-4/4-4-4/03.jpg)

> 次に、最後の 2 行を結合して節の繰り返しを強調します。前の手順の出力を確認すると、リスト内に 2 つの項目が含まれていることがわかります。

> 1. 2 つの List.GetItemAtIndex ノードを使用し、0 と 1 を index 入力の値として指定することにより、2 つの項目を分離することができます。
2. 各ノードの出力として、最後の 2 行が順に表示されます。

![文字列の分割](images/4-4/4-4-4/04.jpg)

> これらの 2 つの項目を 1 つに結合するには、String.Join ノードを使用します。

> 1. String.Join ノードを追加したら、セパレータを指定する必要があります。
2. セパレータを指定するには、キャンバスに String ノードを追加してカンマを入力します。
3. 最終的な出力として、最後の 2 行が 1 行に結合されます。

このように、最後の 2 行を分割する作業は手間がかかります。文字列の操作では、多くの場合、事前の作業が必要になります。ただし、文字列の操作は拡張可能であるため、大規模なデータセットにも比較的簡単に適用することができます。スプレッドシートでパラメータを使用して対話式に操作する場合は、文字列の操作を実行すると便利です。

