

## N 次元のリスト

ここでは、データ階層にさらに層を追加して、より高度なリストの操作方法について見ていきます。データ構造を拡張して、2 次元を超える多次元のリストのリストを作成することができます。Dynamo のリストは項目として処理されるため、必要な数の次元を持つデータを作成することができます。

多次元のリストの構造は、ロシアのマトリョーシカ人形に似ています。各リストは、複数の項目を格納するコンテナとして考えることができます。各リストには独自のプロパティが存在し、それぞれのリストは独自のオブジェクトとして見なされます。

![人形](images/6-4/145493363_fc9ff5164f_o.jpg)

> ロシアのマトリョーシカ人形(写真: [Zeta](https://www.flickr.com/photos/beppezizzi/145493363))は、N 次元のリストの構造に似ています。 それぞれの層が 1 つのリストを表し、各リスト内に項目が格納されています。Dynamo では、1 つのリストに複数のリストを格納することができます。この場合、格納されているそれぞれのリストが、格納元のリストの項目になります。

N 次元のリストを視覚的に説明するのは難しいため、この章ではいくつかの演習を使用して、2 次元を超える多次元のリストを操作する方法について見ていきます。

## マッピングと組み合わせ

Dynamo のデータ管理において最も複雑な概念はマッピングですが、複雑なリスト階層を操作する場合は特に、マッピングが重要になります。この章の演習では、多次元のデータを操作する際に、どのようなケースでマッピングと組み合わせ機能を使用するかについて説明します。

List.Map ノードと List.Combine ノードの概要については、前の章で説明しました。この章の最後の演習でこれらのノードを使用して、複雑なデータ構造の操作を行います。

### 演習 - 2 次元のリスト - 基本的な操作

> この演習に付属しているサンプル ファイルをダウンロードしてください(右クリックして[名前を付けてリンク先を保存]を選択)。すべてのサンプル ファイルの一覧については、付録を参照してください。1.[n-Dimensional-Lists.dyn](datasets/6-4/n-Dimensional-Lists.dyn) 2.[n-Dimensional-Lists.sat](datasets/6-4/n-Dimensional-Lists.sat)

この章では、読み込んだジオメトリを操作するための演習を 3 つ見ていきます。この演習はその最初の演習です。演習を進めていくにつれて、より複雑なデータ構造を扱います。

![演習](images/6-4/Exercise/A/04.jpg)

> 1. 最初に、演習ファイル フォルダ内の .sat ファイルを使用します。このファイルを取得するには、*File Path* ノードを使用します。
2. *Geometry.ImportFromSAT* ノードを使用すると、ジオメトリが 2 つのサーフェスとして Dynamo のプレビューに読み込まれます。

![演習](images/6-4/Exercise/A/03.jpg)

> 説明を簡単にするため、この演習では 1 つのサーフェスだけを使用します。

> 1. インデックス値として *1* を選択して、上部のサーフェスをグラブします。 これを行うには、*List.GetItemAtIndex* ノードを使用します。

![演習](images/6-4/Exercise/A/02.jpg)

> 次に、グラブしたサーフェスを点のグリッドに分割します。

> 1. *Code Block* ノードを使用して、次の 2 つのコード行を入力します。
```
0..1..#10;
0..1..#5;
```

2. 上記のコード行を、*Surface.PointAtParameter* ノードの *u* 入力と *v* 入力に接続します。 次に、このノードの*レーシング*を「*直積*」に変更します。
3. 出力としてデータ構造が表示されます。このデータ構造は、Dynamo のプレビューで表示することもできます。

![演習](images/6-4/Exercise/A/01.jpg)

> 1. *NurbsCurve.ByPoints* ノードを *Surface.PointAtParameter* ノードの出力に接続して、データ構造の内容を確認します。
2. サーフェスに沿って垂直方向に 10 本の曲線が表示されます。

![演習](images/6-4/Exercise/A/00.jpg)

> 1. 基本的な *List.Transpose* ノードにより、リストのリストの列と行が反転します。
2. *List.Transpose* ノードの出力を *NurbsCurve.ByPoints* ノードに接続すると、サーフェスに沿って水平方向に 5 本の曲線が作成されます。

### 演習 - 2 次元のリスト - 高度な操作

この演習では、少し複雑な操作を実行してみましょう。ここでは、前の演習で作成した曲線に対して操作を実行します。具体的には、これらの曲線を別のサーフェスに関連付けて、2 つのサーフェス間で曲線をロフトします。この操作を実行する場合、データ構造の処理が少し複雑になりますが、基本的な考え方はこれまでと同じです。

![演習](images/6-4/Exercise/B/07.jpg)

> 1. 最初に、*List.GetItemAtIndex* ノードを使用して、前の演習で読み込んだジオメトリの上部サーフェスを分離します。

![演習](images/6-4/Exercise/B/06.jpg)

> 1. *Surface.Offset* ノードで *10* という値を指定して、サーフェスをオフセットします。

![演習](images/6-4/Exercise/B/05.jpg)

> 1. 前の演習と同様に、*Code Block* ノードで次の 2 つのコード行を入力します。
```
0..1..#10;
0..1..#5;
```

2. 上記のコード行を 2 つの *Surface.PointAtParameter* ノードに接続し、各ノードの*レーシング*を「*直積*」に設定します。 いずれか一方のノードが元のサーフェスに接続され、もう一方のノードがオフセットされたサーフェスに接続されます。

![演習](images/6-4/Exercise/B/04.jpg)

> 1. 前の演習と同様に、Surface.PointAtParameter ノードの出力を 2 つの *NurbsCurve.ByPoints* ノードに接続します。
2. Dynamo のプレビューに、2 つのサーフェスに対応する 2 組の曲線が表示されます。

![演習](images/6-4/Exercise/B/03.jpg)

> 1. *List.Create* ノードを使用して、2 組の曲線を 1 つのリストのリストに結合します。
2. 10 個の項目を持つ 2 つのリストが出力として表示されます。各リストが、NURBS 曲線の各接続セットを表しています。
3. *Surface.ByLoft* ノードを実行すると、このデータ構造を視覚的に理解することができます。 このノードは、各サブリスト内のすべての曲線をロフトします。

![演習](images/6-4/Exercise/B/02.jpg)

> 1. *List.Transpose* ノードを使用すると、リスト内のすべての列と行が反転します。 このノードにより、10 本の曲線を持つ 2 つのリストが、2 本の曲線を持つ 10 個のリストに変換されます。また、各 NURBS 曲線が、もう一方のサーフェスの隣接する曲線に関連付けられます。
2. *Surface.ByLoft* ノードを使用して、リブ形状の構造物を作成します。

![演習](images/6-4/Exercise/B/01.jpg)

> 1. ここでは、*List.Transpose* ノードの代わりに *List.Combine* ノードを使用します。 このノードは、各サブリスト上で「*コンビネータ*」を実行します。
2. この演習では、*List.Create* ノードを「*コンビネータ*」として使用します。これにより、サブリスト内の各項目のリストが作成されます。
3. *Surface.ByLoft* ノードを使用して、前の手順と同じサーフェスを取得します。この場合は List.Transpose ノードを使用した方が簡単ですが、さらに複雑なデータ構造を操作する場合は、*List.Combine* ノードを使用することをお勧めします。

![演習](images/6-4/Exercise/B/00.jpg)

> 1. リブ形状の構造物内の曲線の方向を切り替える場合は、手順をいくつか戻り、*NurbsCurve.ByPoints* ノードに接続する前に List.Transpose ノードを使用します。 これにより、リスト内の列と行が反転し、水平方向のリブ形状が 5 つ作成されます。

### 演習 - 3 次元のリスト

ここからは、さらに高度な操作を実行してみましょう。この演習では、読み込んだ 2 つのサーフェスを両方とも使用して、複雑なデータ階層を作成します。ただし、基本的な考え方はこれまでと同じで、同じ操作を実行することになります。

![演習](images/6-4/Exercise/C/12.jpg)

> 1. 最初に、前の演習で読み込んだファイルを使用します。

![演習](images/6-4/Exercise/C/11.jpg)

> 1. 前の演習と同様に *Surface.Offset* ノードを使用し、サーフェスをオフセットする値として *10* を指定します。
2. オフセットされたノードによって 2 つのサーフェスが作成されたことが出力として表示されます。

![演習](images/6-4/Exercise/C/10.jpg)

> 1. 前の演習と同様に、Code Block で次の 2 つのコード行を入力します。
```
0..1..#20;
0..1..#10;
```

2. 上記のコード行を 2 つの *Surface.PointAtParameter* ノードに接続し、各ノードのレーシングを「*直積*」に設定します。 いずれか一方のノードが元のサーフェスに接続され、もう一方のノードがオフセットされたサーフェスに接続されます。

![演習](images/6-4/Exercise/C/09.jpg)

> 1. 前の演習と同様に、Surface.PointAtParameter ノードの出力を 2 つの *NurbsCurve.ByPoints* ノードに接続します。
2. *NurbsCurve.ByPoints* ノードの出力を確認すると、この出力が 2 つのリストを持つリストであることがわかります。これは、前の演習で扱ったリストよりも複雑なデータ構造です。 データは基礎となるサーフェスによって分類されるため、構造化されたデータに別の層を追加します。
3. *Surface.PointAtParameter* ノードでは、データ構造がさらに複雑になっていることがわかります。 このノードでは、「リストのリストのリスト」が作成されます。

![演習](images/6-4/Exercise/C/08.jpg)

> 1. *List.Create* ノードを使用して、NURBS 曲線を 1 つのデータ構造にマージします。これにより、「リストのリストのリスト」が作成されます。
2. *Surface.ByLoft* ノードを接続すると、元のサーフェスが取得されます。これは、元のデータ構造から作成された独自のリスト内にサーフェスがそのまま残っているためです。

![演習](images/6-4/Exercise/C/07.jpg)

> 1. 前の演習では、*List.Transpose* ノードを使用してリブ形状の構造物を作成しましたが、 ここでは同じ操作を行うことはできません。List.Transpose ノードを使用できるのは 2 次元のリストの場合ですが、ここでは 3 次元のリストを操作するため、リスト内の列と行を反転する操作を簡単に実行することはできません。これまでに説明したように、リストはオブジェクトとして処理されるため、サブリストが含まれていないリストを *List.Transpose* ノードを使用して反転することはできますが、階層内の 1 段階下の層でリストの NURBS 曲線を反転することはできません。

![演習](images/6-4/Exercise/C/06.jpg)

> 1. ここでは、*List.Combine* ノードを使用します。 さらに複雑なデータ構造を処理する場合は、*List.Map* ノードと *List.Combine* ノードを使用します。
2. *List.Create* ノードを「*コンビネータ*」として使用して、この操作に適したデータ構造を作成します。

![演習](images/6-4/Exercise/C/05.jpg)

> 1. 階層内の 1 段階下の層で、データ構造を転置する必要があります。これを行うには、*List.Map* ノードを使用します。 このノードは *List.Combine* ノードに似ていますが、複数の入力リストではなく 1 つの入力リストだけを使用する点が異なっています。
2. *List.Map* ノードに *List.Transpose* ノードを適用します。これにより、メイン リスト内のサブリストの列と行が反転します。

![演習](images/6-4/Exercise/C/04.jpg)

> 1. これで、適切なデータ階層を持つ NURBS 曲線をまとめてロフトし、リブ形状の構造物を作成できるようになりました。

![演習](images/6-4/Exercise/C/03.jpg)

> 1. ここでは、*Surface.Thicken* ノードを使用して、ジオメトリに深さを設定してみましょう。

![演習](images/6-4/Exercise/C/02.jpg)

> 1. この構造物にサーフェスを追加して補強してみましょう。*List.GetItemAtIndex* ノードを使用して、前の手順でロフトしたサーフェスのうち、背面サーフェスを選択します。

![演習](images/6-4/Exercise/C/01.jpg)

> 1. 選択したサーフェスに厚みをつければ、操作は完了です。

![演習](images/6-4/Exercise/C/00.jpg)

> これで、さまざまなデータを使用したロッキング チェアが完成しました。

![演習](images/6-4/Exercise/C/32.jpg)

> 最後に、ロッキング チェアの溝の方向を変えてみましょう。前の演習では転置用のノードを使用しましたが、ここでも同じような方法で操作を行います。

> 1. データ階層にもう 1 つ深い層があるため、*List.Map* ノードと *List.Tranpose* ノードを使用して溝の方向を変更します。

![演習](images/6-4/Exercise/C/31.jpg)

> 1. Code Block ノードのコード行を次のように変更して、溝の数を増やします。
```
0..1..#20;
0..1..#10;
```

![演習](images/6-4/Exercise/C/30.jpg)

> 最初に作成したロッキング チェアは滑らかな形状でしたが、このロッキング チェアはまったく異なる形状になりました。

