

## Многомерные списки

Добавим еще больше уровней в иерархию и углубимся в нашу кроличью нору. Структура данных может быть гораздо более объемной, чем простой двумерный список списков. Поскольку списки являются самостоятельными элементами в Dynamo, мы можем создать данные с практически неограниченным количеством измерений.

Это похоже на матрешку. Каждый список можно рассматривать как один контейнер, который содержит несколько элементов. Каждый список обладает собственными свойствами и рассматривается как отдельный объект.

![Матрешки](images/6-4/145493363_fc9ff5164f_o.jpg)

> Набор матрешек (фотография предоставлена [Zeta](https://www.flickr.com/photos/beppezizzi/145493363)) является аналогией многомерных списков. Каждый слой представляет список, и каждый список содержит элементы. В Dynamo каждый контейнер может содержать несколько контейнеров (представляющих элементы каждого списка).

Многомерные списки сложно объяснить визуально, но в данном разделе есть несколько упражнений, которые помогут вам разобраться в работе со списками, число измерений которых превышает два.

## Сопоставление и комбинации

Сопоставление — возможно, самый сложный аспект управления данными в Dynamo, особенно когда речь идет о сложных иерархических структурах, состоящих из списков. В рамках приведенных ниже упражнений мы рассмотрим случаи, в которых следует использовать сопоставление и комбинации при работе с многомерными данными.

Основные сведения по работе с узлами List.Map и List.Combine можно найти в предыдущем разделе. Эти узлы будут использованы для работы со сложной структурой данных в последнем из приведенных ниже упражнений.

### Упражнение. Двумерные списки. Основы

> Скачайте файлы примера для этого упражнения (щелкните правой кнопкой мыши и выберите «Сохранить ссылку как...»). Полный список файлов примеров можно найти в приложении. 
1.[n-Dimensional-Lists.dyn](datasets/6-4/n-Dimensional-Lists.dyn) 
2.[n-Dimensional-Lists.sat](datasets/6-4/n-Dimensional-Lists.sat)

Это первое из трех упражнений, направленных на работу с импортированной геометрией. От упражнения к упражнению структура данных будет усложняться.

![Упражнение](images/6-4/Exercise/A/04.jpg)

> 1. Начнем с файла SAT, расположенного в папке с файлами для упражнения. Добавим его в приложение с помощью узла *File Path*.
2. Узел *Geometry.ImportFromSAT* импортирует геометрию в Dynamo и отображает ее в виде двух поверхностей.

![Упражнение](images/6-4/Exercise/A/03.jpg)

> Для простоты в этом упражнении вы будете работать только с одной поверхностью.

> 1. Чтобы выбрать верхнюю поверхность, задайте индекс *1*. Для этого добавьте узел *List.GetItemAtIndex*.

![Упражнение](images/6-4/Exercise/A/02.jpg)

> Теперь нужно преобразовать поверхность в сетку из точек.

> 1. С помощью узла *Code Block* вставьте две следующие строки кода:
```
0..1..#10;
0..1..#5;
```

2. Используя узел *Surface.PointAtParameter*, соедините два значения Code Block с портами ввода *u *и *v*. Задайте для параметра *Переплетение* этого узла значение *декартово произведение*.
3. Полученная структура данных отображается в области предварительного просмотра Dynamo.

![Упражнение](images/6-4/Exercise/A/01.jpg)

> 1. Чтобы отобразить структуру данных, соедините узел *NurbsCurve.ByPoints* с портом вывода узла *Surface.PointAtParameter*.
2. В области предварительного просмотра отображаются десять кривых, идущих вертикально вдоль поверхности.

![Упражнение](images/6-4/Exercise/A/00.jpg)

> 1. Базовый узел *List.Transpose* позволяет поменять местами столбцы и строки в списке списков.
2. При соединении порта вывода узла *List.Transpose* с узлом *NurbsCurve.ByPoints* вы получите пять кривых, идущих горизонтально вдоль поверхности.

### Упражнение. 2D-списки. Для опытных пользователей

Усложним задачу. Предположим, что нам нужно выполнить определенное действие с кривыми, которые мы получили в предыдущем упражнении. Например, нужно связать эти кривые с другой поверхностью и выполнить лофтинг между ними По сути, логика остается прежней, но задача требует более внимательной работы со структурой данных.

![Упражнение](images/6-4/Exercise/B/07.jpg)

> 1. Начнем с операции, уже знакомой вам по предыдущему упражнению. Изолируйте верхнюю поверхность импортированной геометрии с помощью узла *List.GetItemAtIndex*.

![Упражнение](images/6-4/Exercise/B/06.jpg)

> 1. Используя узел *Surface.Offset*, задайте значение *10*, чтобы сместить поверхность.

![Упражнение](images/6-4/Exercise/B/05.jpg)

> 1. Как и в предыдущем упражнении, добавьте узел *Code Block* с двумя строками кода:
```
0..1..#10;
0..1..#5;
```

2. Соедините порты вывода этого узла с двумя узлами *Surface.PointAtParameter* и задайте для параметра *Переплетение* каждого из них значение *декартово произведение*. Один из этих узлов соединен с исходной поверхностью, а второй — с поверхностью смещения.

![Упражнение](images/6-4/Exercise/B/04.jpg)

> 1. Как и в предыдущем упражнении, соедините порты вывода с двумя узлами *NurbsCurve.ByPoints*.
2. В области предварительного просмотра Dynamo отображаются две кривые, соответствующие двум поверхностям.

![Упражнение](images/6-4/Exercise/B/03.jpg)

> 1. С помощью узла *List.Create* можно объединить два набора кривых в один список списков.
2. В результате создаются два списка с десятью элементами, каждый из которых представляет собой связанный набор NURBS-кривых.
3. С помощью узла *Surface.ByLoft* можно создать визуальное представление этой структуры данных. Узел выполняет лофтинг для всех кривых в каждом списке.

![Упражнение](images/6-4/Exercise/B/02.jpg)

> 1. Как вы помните, узел *List.Transpose* позволяет поменять местами столбцы и строки в списке списков. В результате использования этого узла два списка из десяти кривых каждый преобразуются в десять списков из двух кривых каждый. Теперь каждая NURBS-кривая связана с соседней кривой на другой поверхности.
2. С помощью узла *Surface.ByLoft* мы получили реберную конструкцию.

![Упражнение](images/6-4/Exercise/B/01.jpg)

> 1. Вместо узла *List.Transpose* можно использовать узел *List.Combine*. Он выполняет роль *«обьединителя»* для каждого вложенного списка.
2. В данном случае мы используем *List.Create* в качестве *«обьединителя»* для создания списка по каждому элементу во вложенных списках.
3. Добавив узел *Surface.ByLoft*, мы получаем те же поверхности, что и в предыдущем шаге. В данном случае узел Transpose является более простым вариантом, но при работе с еще более сложной структурой данных надежнее будет использовать узел *List.Combine*.

![Упражнение](images/6-4/Exercise/B/00.jpg)

> 1. Вернемся на несколько шагов назад. Если вы хотите изменить ориентацию кривых в реберной конструкции, узел List.Transpose следует применить до соединения с узлом *NurbsCurve.ByPoints*. В результате столбцы и строки поменяются местами, и мы получим пять горизонтальных ребер.

### Упражнение. Трехмерные списки

Продолжаем усложнять задачи. В этом упражнении мы используем обе импортированные поверхности, чтобы создать сложную иерархическую структуру данных. По сути, вам предстоит выполнить то же самое действие, пользуясь той же самой логикой, что и ранее.

![Упражнение](images/6-4/Exercise/C/12.jpg)

> 1. Вернемся к файлу, импортированному в предыдущем упражнении.

![Упражнение](images/6-4/Exercise/C/11.jpg)

> 1. Как и в предыдущем упражнении, используйте узел *Surface.Offset*, чтобы задать значение смещения, равное *10*.
2. Обратите внимание, что добавление узла смещения привело к созданию двух поверхностей.

![Упражнение](images/6-4/Exercise/C/10.jpg)

> 1. Как и в предыдущем упражнении, добавьте узел Code Block с двумя строками кода:
```
0..1..#20;
0..1..#10;
```

2. Соедините порты вывода этого узла с двумя узлами *Surface.PointAtParameter* и задайте для параметра «Переплетение» каждого из них значение *декартово произведение*. Один из этих узлов соединен с исходными поверхностями, а второй — с поверхностями смещения.

![Упражнение](images/6-4/Exercise/C/09.jpg)

> 1. Как и в предыдущем упражнении, соедините порты вывода с двумя узлами *NurbsCurve.ByPoints*.
2. Посмотрите на выходные данные узла *NurbsCurve.ByPoints* и обратите внимание, что они представляют собой список, состоящий из двух списков, что является более сложной структурой, чем в предыдущем упражнении. Данные упорядочиваются по базовой поверхности, поэтому в структуру данных добавлен еще один уровень.
3. Обратите внимание, что структура данных в узле *Surface.PointAtParameter* стала более сложной. В нем представлен список, состоящих из списков списков.

![Упражнение](images/6-4/Exercise/C/08.jpg)

> 1. С помощью узла *List.Create* объедините NURBS-кривые в одну структуру данных, чтобы создать список, состоящий из списков списков.
2. При подключении узла *Surface.ByLoft* мы получаем новую версию исходных поверхностей, так как они остаются в собственном списке в соответствии с исходной структурой данных.

![Упражнение](images/6-4/Exercise/C/07.jpg)

> 1. В предыдущем упражнении мы использовали узел *List.Transpose* для создания реберной конструкции. В этом случае данная функция не подходит. Перенос следует использовать с двумерными списками, но мы имеем дело с трехмерным списком, поэтому перестановка столбцов и строк не сработает. Поскольку списки являются объектами, то узел *List.Transpose* выполнит перестановку между списками с вложенными списками, но она не затронет NURBS-кривые в списках на уровень ниже.

![Упражнение](images/6-4/Exercise/C/06.jpg)

> 1. В этом случае *List.Combine* является более подходящим инструментом. При работе с более сложными структурами данных используются узлы *List.Map* и *List.Combine*.
2. Используя *List.Create* в качестве *«обьединителя»*, создайте структуру данных, которая лучше подойдет для ваших целей.

![Упражнение](images/6-4/Exercise/C/05.jpg)

> 1. Структуру данных все еще требуется перенести на один уровень вниз по иерархии. Для этого используйте узел *List.Map*. Его работа аналогична узлу *List.Combine*, однако в нем используется только один список входных данных, а не два или больше.
2. К узлу *List.Map* будет применена функция *List.Transpose*, которая меняет местами столбцы и строки вложенных списков в главном списке.

![Упражнение](images/6-4/Exercise/C/04.jpg)

> 1. Наконец, выполните лофтинг между NURBS-кривыми с использованием соответствующей иерархии данных, чтобы получить реберную конструкцию.

![Упражнение](images/6-4/Exercise/C/03.jpg)

> 1. Придайте геометрии глубину с помощью узла *Surface.Thicken*.

![Упражнение](images/6-4/Exercise/C/02.jpg)

> 1. Добавим вспомогательную поверхность для этих двух конструкций. Используйте узел *List.GetItemAtIndex*, чтобы выбрать заднюю поверхность из поверхностей лофтинга, созданных в предыдущих шагах.

![Упражнение](images/6-4/Exercise/C/01.jpg)

> 1. Теперь увеличьте толщину выбранных поверхностей.

![Упражнение](images/6-4/Exercise/C/00.jpg)

> В результате мы получили нечто, похожее на слегка неустойчивое кресло-качалку. Зато сколько данных ушло на его создание!

![Упражнение](images/6-4/Exercise/C/32.jpg)

> Наконец, изменим направление бороздок. Для этого выполните процедуру, аналогичную преобразованию, которое вы уже использовали ранее.

> 1. Так как здесь присутствует еще один уровень иерархии, то используйте узел *List.Map* с функцией *List.Tranpose*, чтобы изменить направление NURBS-кривых.

![Упражнение](images/6-4/Exercise/C/31.jpg)

> 1. Если требуется увеличить количество канавок, то данные узла Code Block можно изменить на следующие:
```
0..1..#20;
0..1..#10;
```

![Упражнение](images/6-4/Exercise/C/30.jpg)

> Если первая версия кресла-качалки была обтекаемой, то вторая получилась более похожей на колесо внедорожника.

