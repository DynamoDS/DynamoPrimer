

## Логика

**Логика** (точнее **условная логика**) позволяет задать действие или набор действий в зависимости от результата проверки. После прохождения проверки выдается логическое значение ```Истина``` или ```Ложь```, которое можно использовать для управления ходом программы.

### Логические выражения

Числовые переменные могут хранить целый диапазон различных чисел. В логических переменных хранятся только два значения: «Истина» или «Ложь», да или нет, 1 или 0. Из-за ограниченной применимости логические операции можно не так часто встретить в расчетах.

### Условные выражения

Выражение If является ключевым для программирования. Если *некое условие* истинно, то происходит*что-то одно*, в противном случае происходит *что-то другое*. Действие, выполняемое после проверки с помощью данного выражения, зависит от логического значения. Существует несколько способов определения выражения If в Dynamo.

|Значок|Имя|Синтаксис|Входные данные|Выходные данные|
| -- | -- | -- | -- | -- |
|![](../images/icons/DSCoreNodesUI-Logic-If-Large.jpg)|If|If|проверка, истина, ложь|результат|
|![](../images/icons/DSCoreNodesUI-Formula-Large.jpg)|Формула|IF(x,y,z)|x, y, z|результат|
|![](../images/icons/Dynamo-Nodes-CodeBlockNodeModel-Large.jpg)|Блок кода|(x?y:z)|x, y, z|результат|

Рассмотрим краткий пример с каждым из этих трех узлов в действии, используя условное выражение If.

![](images/4-3/IFs.jpg)

> На этом изображении в узле *boolean* задано значение *true*. Это означает, что на выводе появится строка *this is the result if true (это результат при истинном значении).* Три узла, образующие выражение *If*, работают одинаково.

![](images/4-3/IFs2.jpg)

> Напомним, что узлы работают одинаково. Если изменить значение *boolean* на *false*, результатом будет число *пи*, как определено в исходном операторе *If*.

### Фильтрация списка

> Скачайте файл примера для этого упражнения (щелкните правой кнопкой мыши и выберите «Сохранить ссылку как...»): [Building Blocks of Programs - Logic.dyn](datasets/4-3/Building Blocks of Programs - Logic.dyn). Полный список файлов примеров можно найти в приложении.

Используем логику, чтобы разделить список чисел на списки четных и нечетных чисел.

![](images/4-3/01.jpg)

> 1. **Number Range.** Добавьте диапазон чисел в рабочую область.
2. **Числа.** Добавьте три узла Number в рабочую область. Каждый узел Number должен иметь следующие значения: *0.0* для *start*, *10.0* для *end* и *1.0* для *step*.
3. **Выходные данные.** На выходе получается список из 11 чисел в диапазоне от 0 до 10.
4. **Коэффициент (%).** *Диапазон номеров * в качестве входных данных для *x* и значение *2.0* в качестве входных данных для *y*. При этом рассчитывается остаток каждого числа в списке при делении на 2. На выходе из этого списка будет представлен список чередующихся значений 0 и 1.
5. **Проверка равенства (==).** Добавьте в рабочую область проверку равенства. Соедините выходные данные *коэффициента*с входным параметром *x*, а значение *0.0* с входных параметром *y*.
6. **Watch**. В качестве выходных данных проверки равенства будет представлен список значений «Истина» или «Ложь». С помощью этих значений элементы будут разделяться в списке. *0* (или *true*) соответствует четным числам, а *1* (или *false*) — нечетным.
7. **List.FilterByBoolMask.** Этот узел отфильтровывает значения по двум разным спискам в зависимости от вводимого логического выражения. Соедините исходный *диапазон чисел* с входным параметром *list*, а выходной параметр *проверки равенства* с входным параметром *mask*. В выходных данных *in* представлены истинные значения, а в *out* — ложные.
8. **Watch.** В результате мы получили списки четных и нечетных чисел. Итак, с помощью логических операторов мы разделили списки по определенному признаку.

### От логики к геометрии

Применим логику из первого упражнения к моделированию.

![](images/4-3/02.png) За основу возьмем предыдущее упражнение с теми же узлами. Помимо изменения формата единственными исключениями будут следующие.

> 1. Изменены входные значения.
2. Отсоединен входной параметр list из узла *List.FilterByBoolMask*. Эти узлы пока не нужны, но они потребуются позже.

![](images/4-3/03.png)

> Начнем с соединения узлов вместе, как показано на изображении выше. Эта группа узлов представляет собой параметрическое уравнение для определения линейной кривой. Примечания.

> 1. **Первый регулятор** должен иметь значение не менее 1, не более 4 и шаг 0,01.
2. **Второй регулятор** должен иметь значение не менее 0, не более 1 и шаг 0,01.
3. **PolyCurve.ByPoints.** Если скопировать приведенную выше схему узлов, на видовом экране предварительного просмотра Dynamo будет создана синусоидальная кривая.

При вводе данных используйте числовые узлы для более статических свойств и регуляторы чисел для более гибких свойств. Необходимо сохранить исходный диапазон чисел, который определяется в начале этого шага. Однако синусоидальная кривая, которую мы пытаемся создать, должна обладать определенной гибкостью. Перемещая регуляторы, можно видеть частотные и амплитудные изменения кривой.

![](images/4-3/04.png)

> Заглянем немного вперед и посмотрим на конечный результат, чтобы представить, каким он должен быть. Первые два шага выполняются отдельно, теперь их нужно соединить. С помощью базовой синусоидальной кривой будет определяться местоположение компонентов молнии, а с помощью логики «истина/ложь» — элементы меньшего или большего размера.

![](images/4-3/05.png)

> 1. **Math.RemapRange.** С помощью последовательности чисел, созданной в шаге 01, сформируем новую последовательность чисел, перенастроив диапазон. Исходные числа из шага 01 имеют диапазон от 0 до 100. С помощью входных параметров *newMin* и *newMax* диапазон значений изменяется на 0–1 соответственно.

![](images/4-3/06.png)

> 1. **Curve.PointAtParameter.** Соедините узел *Polycurve.ByPoints* (из шага 2) с входным параметром *curve*, а узел *Math.RemapRange* с входным параметром *param*. В этом шаге создаются точки вдоль кривой. Диапазон чисел был перенастроен на 0–1, так как входной параметр *param* ищет значения в этом диапазоне. Значение *0* соответствует начальной точке, а значение *1* — конечным точкам. Все промежуточные числа относятся к диапазону *[0,1]*.

![](images/4-3/07.png)

> 1. **List.FilterByBoolMask.** Соедините узел *Curve.PointAtParameter* из предыдущего шага с входным параметром *list*.
2. **Watch.** Узел Watch для *in* и узел Watch для *out* показывают, что имеется два списка — четных и нечетных индексов. Тот же самый порядок точек используется в кривой, что демонстрируется в следующем шаге.

![](images/4-3/08.png)

> 1. **Cuboid.ByLength.** Для создания молнии вдоль синусоидальной кривой воспроизведите связи, представленные на изображении выше. В данном случае кубоид — это просто рамка, размер которой определяется в зависимости от точки кривой в центре рамки. Теперь логика четных/нечетных делений в модели должна быть понятной.

![](images/4-3/matrix.png)

> 1. **Number Slider.** Вернувшись в начало процедуры, можно переключить регулятор чисел, наблюдая, как изменится молния. В верхней серии изображений представлен диапазон значений для верхнего регулятора. Это частота волны.
2. **Number Slider.** В нижней серии изображений представлен диапазон значений для нижнего регулятора. Это амплитуда волны.

